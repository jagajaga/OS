Process = r ~> Context

ProcessInfo = record
{ pid : Int 
    ruid : Int 
    rgid : Int 
    euid : Int
    egid : Int 
    ppid : Int 
    gids : [Int] 
    pwd : Path 
    namespace : Map<Path, Inode*> 
    fdTable : Map<int, FdId> 
}

FdId = record
{
    fdInfo : FdInfo
    data : Ptr 
}

FdInfo = record
{
    flags: Set 
    SeekPos: VeryLongInt
}

Inode = record
{ 
    type: File | Dir 
    atime : datetime 
    mtime : datetime 
    modes : Int 
    owner : Int
    group : Int
    data: IDataType* 
}

Registers = record
{
    hr0
    hr1
    hr2 
    hr3
    .....
}

HD = record
{
    mmu: PointerTable 
    registers: Registers 
}

r~> Context = record
{
    ret: *r 
    processInfo: ProcessInfo
    kas: *HD 
}

Context = record
{
    tag: SyscallTag 
    Argv: Arg tag 
    Cont: Process(Ret tag) 
}
//copyright Dmitry Bobrov

kernel()
{
    runnable = List<Process>
    waiting = Map<Process, SyscallTag>

    white_pages = List<Ptr>
    black_pages = List<Ptr>

    associated_map = Map <Prt, DiskBlockId>
    waiting_for_deassociate_map = Map <Prt, DiskBlockId>

    allocating_map = Map <Pid, Ptr>

    while true
    {
	current_process = runnable.head()
	context = current_process.exec()
	allocator = allocator(current_process.hd.mmu)
	disk = driver.get_disk()
	switch context.tag
	{
		case fork_tag:
			pid = new_pid()
			runnable.add(Process(pid, context.cont(0), ...))
			runnable.add(Process(current_process.pid, context.cont(pid), ...))
			break
		case exit_tag:
			return
		case alloc_ram_pages_tag:
			k = context.argv[0]
			if (allocator.get_free_ram() <= k)
			{
			    allocator.allocate(k, current_process.pid) // (size, pid)
			    //after if allocates memory it will add process to runnable with alloc_ram_done syscall tag and add to allocating_map new entry with ptr
			    break
			}
			else
			{
			    new_k_size = k - allocator.get_free_ram()
			    allocator.allocate(new_k_size, pid)
			}
		case alloc_ram_done:
		    ptr = allocating_map[current_process.pid]
		    white_pages.add(ptr);
		    runnable.add(Process(..., context.cont(ptr))
		    allocating_map.remove_entry(current_process.pid)
		case alloc_disk_pages_tag:
			k = context.argv[0]
			id = disk.allocate_block(k)
			runnable.add(Process(..., context.cont(id))
			break
		case read_block_tag:
		case write_block_tag:
		case associate:
		case deassociate:
	}
    }
}
