Process = r ~> Context

ProcessInfo = record
{ pid : Int 
    ruid : Int 
    rgid : Int 
    euid : Int
    egid : Int 
    ppid : Int 
    gids : [Int] 
    pwd : Path 
    namespace : Map<Path, Inode*> 
    fdTable : Map<int, FdId> 
}

FdId = record
{
    fdInfo : FdInfo
    data : Ptr 
}

FdInfo = record
{
    flags: Set 
    SeekPos: VeryLongInt
}

Inode = record
{ 
    type: File | Dir 
    atime : datetime 
    mtime : datetime 
    modes : Int 
    owner : Int
    group : Int
    data: IDataType* 
}

Registers = record
{
    hr0
    hr1
    hr2 
    hr3
    .....
}

HD = record
{
    mmu: PointerTable 
    registers: Registers 
}

r~> Context = record
{
    ret: *r 
    processInfo: ProcessInfo
    kas: *HD 
}

Context = record
{
    tag: SyscallTag 
    Argv: Arg tag 
    Cont: Process(Ret tag) 
}
//copyright Dmitry Bobrov

kernel()
{
	timer : Timer
    runnable = List<Process>
    waiting = Map<Process, SyscallTag>

    white_pages = List<Ptr>
    black_pages = List<Ptr>
    disk_pages = Map <Process, List<DiskBlockId>>

	disk_activity_map = Map <Process, Process>
    waiting_for_allocation = List<Process>
	waiting_read = List<Process>
	waiting_write = List<Process>

    associated_map = Map <Prt, DiskBlockId>
    waiting_for_deassociate_map = Map <Prt, DiskBlockId>

    allocating_map = Map <Process, Ptr>

    while true
    {
		current_process = runnable.head()
		context = current_process.exec()
		allocator = allocator(current_process.hd.mmu)
		disk = driver.get_disk()
		switch context.tag
		{
			case timer_alarm_tag:
				
			case fork_tag:
				pid = new_pid()
				runnable.add(Process(pid, context.cont(0), ...))
				runnable.add(Process(current_process.pid, context.cont(pid), ...))
				break
			case exit_tag:

			case alloc_ram_pages_tag:
				k = context.argv[0]
				if (ptr = allocator.get_free_page_by_size(k))
				{
					allocator.allocate(ptr, k) 
					white_pages.add(ptr)
					runnable.add(Process(..., context.cont(ptr))
					break
				}
				else
				{
					for (page : white_pages)
					{
					 if (page.get_size() >= k)
					 {
						 white_pages.remove(page)
						 ptr = allocator.allocate(page, k)
						 white_pages.add(ptr)
						 runnable.add(Process(..., context.cont(ptr))
						 break
					 }
					 next = false
					}
					if (!next)
					 break
					for (page : black_pages)
					{
					 if (page.get_size() >= k)
					 {
						 black_pages.remove(page)
						 allocator.release(page)
						 ptr = allocator.allocate(page, k) white_pages.add(ptr)
						 runnable.add(Process(..., context.cont(ptr))
						 break
					 }
					 next = false
					}
					if (!next)
					 break
					disk.add_page(k, current_process) //it will create new disk job, and after it is done it will create interrupt and in first argument where will be process wich was asking for disk allocaating 
					waiting_for_allocation.add(current_process)
					break
				}
			case alloc_disk_done_interrupt:
				was_proc = context.argv[0]
				ptr = context.argv[1]
				disk_pages[was_proc].add(ptr)
				waiting_for_allocation.remove(was_proc)
				runnable.add(Process(was_proc, ..., context.cont(ptr))
				runnable.add(current_process)
				break
			case alloc_disk_pages_tag:
				k = context.argv[0]
				disk.add_page(k, current_process) 
				waiting_for_allocation.add(current_process)
				break
			case read_block_done_interrupt:
				was_proc = context.argv[0]
				count = disk.get_cached_read_count(was_proc)
				waiting_read.remove(was_proc)
				runnable.add(Process(was_proc, ..., context.cont(count))
				runnale.add(current_process)
				break
			case write_block_done_interrupt:
				was_proc = context.argv[0]
				count = disk.get_cached_read_count(was_proc)
				waiting_write.remove(was_proc)
				runnable.add(Process(was_proc, ..., context.cont(count))
				runnale.add(current_process)
				break
			case read_block_tag:
				fd = current_process.fdTable[context.argv[0]]
				buffer = context.argv[1]
				size = context.argv[2]
				disk.read_block(fd, buffer, size, current_process) //same logic as add_page
				break
			case write_block_tag:
				fd = current_process.fdTable[context.argv[0]]
				buffer = context.argv[1]
				size = context.argv[2]
				disk.write_block(fd, buffer, size, current_process) //same logic as add_page
				break
			case page_read_interrupt:
				page = context.argv[0]
				if (white_pages.contains(page))
				{
					white_pages.remove(page)
					black_pages.add(page)
					runnable.add(Process(..., context.cont(page)))
					break
				}
				if (black_pages.contains(page))
				{
					runnable.add(Process(..., context.cont(page)))
					break
				}
				if (disk_pages[current_process].contains(page))
				{
					ptr = allocator.load_to_ram(page)
					disk_pages[current_process].remove(page)
					white_pages.add(ptr)
					runnable.add(Process(..., context.cont(ptr)))
					break
				}
				runnable.add(Process(..., context.cont(exit)))
				break
			case associate:
				ptr = context.argv[0]
				k = context.argv[1]
				//TODO	
			case deassociate:
		}
    }
}
